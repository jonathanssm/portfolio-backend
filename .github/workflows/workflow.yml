name: Deploy Backend to VM

on:
  push:
    branches:
      - main
      - develop
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - main
      - develop

concurrency:
  group: backend-deploy-${{ github.ref_name }}
  cancel-in-progress: true

env:
  VM_HOST: ${{ secrets.BACKEND_VM_IP }}
  VM_USER: ${{ secrets.BACKEND_VM_USER }}
  VM_SSH_KEY: ${{ secrets.BACKEND_VM_SSH_KEY }}
  VM_PATH: /home/ubuntu/backend
  JAR_NAME: portfolio-backend-0.0.1-SNAPSHOT.jar

jobs:
  # ğŸ” ValidaÃ§Ã£o e testes (sempre executa)
  validate:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Java and Cache
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '21'
          cache: 'maven'

      - name: Validate code quality
        run: |
          chmod +x ./mvnw
          ./mvnw -B clean compile test -T 1C
          
          # Verificar se build passou
          if [ $? -eq 0 ]; then
            echo "âœ… Build e testes passaram com sucesso"
          else
            echo "âŒ Build ou testes falharam"
            exit 1
          fi

      - name: Check for security vulnerabilities
        run: |
          # VerificaÃ§Ã£o bÃ¡sica de seguranÃ§a (sem API key para evitar lentidÃ£o)
          echo "ğŸ” Verificando dependÃªncias com vulnerabilidades conhecidas..."
          ./mvnw versions:display-dependency-updates || echo "âš ï¸ Dependency check bÃ¡sico falhou, mas continuando..."
          echo "âœ… VerificaÃ§Ã£o de seguranÃ§a bÃ¡sica concluÃ­da"

  # ğŸš€ Deploy apenas em push (nÃ£o em PR)
  deploy:
    needs: validate
    runs-on: ubuntu-latest
    timeout-minutes: 15
    # SÃ³ executa em push, nÃ£o em PR
    if: github.event_name == 'push'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Setup Java and Cache
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '21'
          cache: 'maven'

      - name: Build JAR with verification
        run: |
          chmod +x ./mvnw
          ./mvnw -B clean package -DskipTests -T 1C
          
          # âœ… VerificaÃ§Ã£o robusta do JAR
          echo "Verifying JAR file..."
          if [ ! -f "target/$JAR_NAME" ]; then
            echo "âŒ JAR file not found in target/"
            ls -la target/
            exit 1
          fi
          
          if [ ! -s "target/$JAR_NAME" ]; then
            echo "âŒ JAR file is empty"
            ls -lh target/
            exit 1
          fi
          
          if file "target/$JAR_NAME" | grep -q "Java archive"; then
            echo "âœ… JAR file is valid"
          else
            echo "âŒ JAR file is not a valid Java archive"
            file "target/$JAR_NAME"
            exit 1
          fi

      - name: Prepare artifacts
        run: |
          cp target/$JAR_NAME .
          ls -la $JAR_NAME Dockerfile

      - name: Setup VM directory
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ env.VM_HOST }}
          username: ${{ env.VM_USER }}
          key: ${{ env.VM_SSH_KEY }}
          script: |
            mkdir -p ${{ env.VM_PATH }}
            cd ${{ env.VM_PATH }}
            rm -rf *.jar Dockerfile 2>/dev/null || true
            echo "VM directory cleaned and ready"

      - name: Copy artifacts to VM
        uses: appleboy/scp-action@v0.1.4
        with:
          host: ${{ env.VM_HOST }}
          username: ${{ env.VM_USER }}
          key: ${{ env.VM_SSH_KEY }}
          source: "${{ env.JAR_NAME }},Dockerfile"
          target: ${{ env.VM_PATH }}
          overwrite: true

      - name: Verify artifacts on VM
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ env.VM_HOST }}
          username: ${{ env.VM_USER }}
          key: ${{ env.VM_SSH_KEY }}
          script: |
            set -e
            cd ${{ env.VM_PATH }}
            
            echo "ğŸ“¦ Verifying artifacts on VM..."
            ls -la
            
            if [ ! -f "${{ env.JAR_NAME }}" ]; then
              echo "âŒ JAR not found on VM"
              exit 1
            fi
            
            if [ ! -s "${{ env.JAR_NAME }}" ]; then
              echo "âŒ JAR is empty on VM"
              exit 1
            fi
            
            echo "âœ… All artifacts verified successfully"

      - name: Deploy Docker container with memory limits
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ env.VM_HOST }}
          username: ${{ env.VM_USER }}
          key: ${{ env.VM_SSH_KEY }}
          envs: GITHUB_EVENT_NAME,GITHUB_REF
          script: |
            set -e
            cd ${{ env.VM_PATH }}

            # ğŸ·ï¸ Determina ambiente com limites de memÃ³ria
            # ğŸ§  OtimizaÃ§Ã£o para VM de 1GB RAM - STAGING E PRODUÃ‡ÃƒO SEMPRE ATIVOS
            # Total disponÃ­vel: ~900MB (sistema usa ~100MB)
            # EstratÃ©gia: Staging + ProduÃ§Ã£o sempre ativos (sem preview)
            # ProduÃ§Ã£o: 450MB, Staging: 350MB, Nginx: 50MB, Sistema: 100MB, Buffer: 50MB
            
            # Deploy sempre executa (job sÃ³ roda em push)
            BRANCH="${GITHUB_REF#refs/heads/}"
            case "$BRANCH" in
              "main")
                ENV="prod"
                PORT="8080"
                MEMORY_LIMIT="450m"  # 450MB para produÃ§Ã£o (sempre ativa)
                JAVA_OPTS="-Xms64m -Xmx360m -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -XX:+UseStringDeduplication -XX:+UseCompressedOops"
                IS_TEMPORARY=false
                ;;
              "develop")
                ENV="staging"
                PORT="8081"
                MEMORY_LIMIT="350m"  # 350MB para staging (sempre ativo)
                JAVA_OPTS="-Xms48m -Xmx280m -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -XX:+UseStringDeduplication -XX:+UseCompressedOops"
                IS_TEMPORARY=false
                ;;
              *)
                echo "ğŸš« Push detected on unsupported branch '$BRANCH'. Skipping deploy."
                exit 0
                ;;
            esac

            IMAGE_NAME="portfolio-backend-$ENV"
            CONTAINER_NAME="portfolio-backend-$ENV"
            
            echo "ğŸš€ Deploying to $ENV environment"
            echo "ğŸ“Š Memory limits: $MEMORY_LIMIT total, JAVA_OPTS: $JAVA_OPTS"
            
            # ğŸ§  Verificar memÃ³ria disponÃ­vel
            echo "ğŸ” Checking system memory..."
            free -h
            echo "ğŸ’¾ Available memory: $(free -m | awk 'NR==2{printf "%.1f%%", $3*100/$2 }')"
            
            # âš ï¸ Aviso se memÃ³ria baixa
            AVAILABLE_MB=$(free -m | awk 'NR==2{print $7}')
            if [ $AVAILABLE_MB -lt 200 ]; then
              echo "âš ï¸ WARNING: Low memory available ($AVAILABLE_MB MB). Consider upgrading VM."
            fi

            # ğŸ³ Verifica Docker
            if ! command -v docker &> /dev/null; then
              echo "ğŸ“¦ Installing Docker..."
              curl -fsSL https://get.docker.com | sudo sh
              sudo systemctl enable docker
            fi

            # ğŸ”§ Configurar swap para evitar OOM
            echo "ğŸ’¾ Configuring swap for memory safety..."
            if [ ! -f /swapfile ]; then
              sudo fallocate -l 1G /swapfile
              sudo chmod 600 /swapfile
              sudo mkswap /swapfile
              sudo swapon /swapfile
              echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab
              echo "âœ… Swap file created (1GB)"
            else
              echo "âœ… Swap file already exists"
            fi
            
            # ğŸ§¹ Limpar containers antigos para liberar memÃ³ria
            echo "ğŸ§¹ Cleaning up old containers and images..."
            sudo docker system prune -af --filter "until=24h" || true
            sudo docker volume prune -f || true

            # ğŸ” Configura certificados SSL
            echo "ğŸ” Setting up SSL certificates..."
            mkdir -p ssl
            
            # SEMPRE criar certificado auto-assinado primeiro (para garantir que nginx suba)
            echo "ğŸ  Criando certificado auto-assinado temporÃ¡rio..."
            
            # Verificar se VM_HOST Ã© IP ou domÃ­nio para configurar SAN corretamente
            echo "ğŸ” Verificando tipo de VM_HOST: ${{ env.VM_HOST }}"
            
            if [[ "${{ env.VM_HOST }}" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              # Ã‰ um IP - usar apenas IP no SAN
              SAN="IP:${{ env.VM_HOST }}"
              echo "âœ… Detectado IP: ${{ env.VM_HOST }}"
            else
              # Ã‰ um domÃ­nio - usar DNS no SAN e tentar IP se possÃ­vel
              SAN="DNS:${{ env.VM_HOST }}"
              echo "âœ… Detectado domÃ­nio: ${{ env.VM_HOST }}"
              
              # Tentar resolver IP do domÃ­nio para incluir no SAN
              echo "ğŸ” Tentando resolver IP do domÃ­nio..."
              RESOLVED_IP=$(nslookup ${{ env.VM_HOST }} 2>/dev/null | grep "Address:" | tail -1 | awk '{print $2}' | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$' || echo "")
              if [ ! -z "$RESOLVED_IP" ]; then
                SAN="${SAN},IP:${RESOLVED_IP}"
                echo "âœ… IP resolvido: $RESOLVED_IP"
              else
                echo "âš ï¸ NÃ£o foi possÃ­vel resolver IP do domÃ­nio"
              fi
            fi
            
            echo "ğŸ“‹ SAN configurado: $SAN"
            
            sudo openssl req -x509 -newkey rsa:4096 -keyout ssl/key.pem -out ssl/cert.pem -days 3650 -nodes \
              -subj "/C=BR/ST=SP/L=SaoPaulo/O=Portfolio/OU=IT/CN=${{ env.VM_HOST }}" \
              -addext "subjectAltName=${SAN}"
            
            # Verificar se Ã© domÃ­nio real para tentar Let's Encrypt
            if [[ ! "${{ env.VM_HOST }}" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]] && [ "${{ env.VM_HOST }}" != "localhost" ] && [ "${{ env.VM_HOST }}" != "127.0.0.1" ]; then
              echo "ğŸŒ Tentando configurar certificados Let's Encrypt para ${{ env.VM_HOST }}"
              
              # Aguarda liberaÃ§Ã£o do lock do apt
              echo "â³ Aguardando liberaÃ§Ã£o do lock do apt..."
              while sudo fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1; do
                echo "   Lock ativo, aguardando 5s..."
                sleep 5
              done
              
              # Instalar certbot se nÃ£o estiver instalado
              if ! command -v certbot &> /dev/null; then
                echo "ğŸ“¦ Instalando certbot..."
                sudo apt-get update
                sudo apt-get install -y certbot
                
                if ! command -v certbot &> /dev/null; then
                  echo "âš ï¸ Falha ao instalar certbot - continuando com certificado auto-assinado"
                  echo "ğŸ”§ Para certificados vÃ¡lidos, instale manualmente: sudo apt-get install certbot"
                else
                  echo "âœ… Certbot instalado com sucesso"
                fi
              else
                echo "âœ… Certbot jÃ¡ estÃ¡ instalado"
              fi
              
              # Tentar gerar certificado Let's Encrypt se certbot estiver disponÃ­vel
              if command -v certbot &> /dev/null; then
                echo "ğŸ” Tentando gerar certificado Let's Encrypt..."
                
                # Verificar se porta 80 estÃ¡ livre
                if ! sudo lsof -i :80 >/dev/null 2>&1; then
                  echo "âœ… Porta 80 estÃ¡ livre, tentando Let's Encrypt..."
                  
                  sudo certbot certonly \
                    --standalone \
                    --non-interactive \
                    --agree-tos \
                    --email "${{ secrets.SSL_EMAIL || format('admin@{0}', env.VM_HOST) }}" \
                    --domains "${{ env.VM_HOST }},staging.jonathanssm.com" \
                    --expand || {
                    echo "âš ï¸ Falha no Let's Encrypt - usando certificado auto-assinado"
                    echo "ğŸ”§ Para certificados vÃ¡lidos:"
                    echo "   1. Verificar se DNS estÃ¡ propagado"
                    echo "   2. Verificar se domÃ­nio aponta para este IP"
                    echo "   3. Aguardar propagaÃ§Ã£o DNS (atÃ© 24h)"
                  }
                  
                  # Verificar se certificados foram gerados
                  if [ -f "/etc/letsencrypt/live/${{ env.VM_HOST }}/fullchain.pem" ]; then
                    sudo cp "/etc/letsencrypt/live/${{ env.VM_HOST }}/fullchain.pem" ssl/cert.pem
                    sudo cp "/etc/letsencrypt/live/${{ env.VM_HOST }}/privkey.pem" ssl/key.pem
                    echo "âœ… Certificados Let's Encrypt configurados com sucesso!"
                    
                    # Configurar renovaÃ§Ã£o automÃ¡tica via cron
                    echo "â° Configurando renovaÃ§Ã£o automÃ¡tica..."
                    (crontab -l 2>/dev/null; echo "0 2 * * * certbot renew --quiet --nginx") | crontab - 2>/dev/null || true
                    echo "âœ… RenovaÃ§Ã£o automÃ¡tica configurada"
                  else
                    echo "âš ï¸ Let's Encrypt falhou - usando certificado auto-assinado"
                  fi
                else
                  echo "âš ï¸ Porta 80 em uso - usando certificado auto-assinado"
                  echo "ğŸ”§ Para Let's Encrypt, pare o serviÃ§o na porta 80 temporariamente"
                fi
              else
                echo "âš ï¸ Certbot nÃ£o disponÃ­vel - usando certificado auto-assinado"
              fi
            else
              echo "ğŸ  Usando certificado auto-assinado para IP/localhost: ${{ env.VM_HOST }}"
            fi
            
            # Define permissÃµes corretas
            sudo chmod 600 ssl/key.pem
            sudo chmod 644 ssl/cert.pem
            sudo chown -R $USER:$USER ssl/
            
            echo "âœ… SSL certificates configured successfully"
            
            # ğŸ” Verificar qual tipo de certificado estÃ¡ sendo usado
            echo "ğŸ” Verificando tipo de certificado configurado..."
            if [ -f "ssl/cert.pem" ]; then
              CERT_SUBJECT=$(openssl x509 -in ssl/cert.pem -noout -subject 2>/dev/null || echo "Erro ao ler certificado")
              CERT_ISSUER=$(openssl x509 -in ssl/cert.pem -noout -issuer 2>/dev/null || echo "Erro ao ler issuer")
              
              echo "ğŸ“‹ InformaÃ§Ãµes do certificado:"
              echo "   Subject: $CERT_SUBJECT"
              echo "   Issuer: $CERT_ISSUER"
              
              # Verificar se Ã© Let's Encrypt ou auto-assinado
              if echo "$CERT_ISSUER" | grep -q "Let's Encrypt"; then
                echo "âœ… CERTIFICADO VÃLIDO (Let's Encrypt) configurado!"
                echo "ğŸ”’ HTTPS seguro e confiÃ¡vel"
              elif echo "$CERT_ISSUER" | grep -q "Portfolio"; then
                echo "âš ï¸ CERTIFICADO AUTO-ASSINADO configurado"
                echo "ğŸ”“ HTTPS funciona mas navegador mostrarÃ¡ aviso de seguranÃ§a"
                echo "ğŸ”§ Para certificado vÃ¡lido: aguarde propagaÃ§Ã£o DNS ou configure manualmente"
              else
                echo "â“ Certificado com issuer desconhecido: $CERT_ISSUER"
              fi
            else
              echo "âŒ Nenhum certificado encontrado em ssl/cert.pem"
            fi

            # ğŸ—ï¸ Build das imagens
            echo "ğŸ”¨ Building Docker images..."
            
            # Verificar se diretÃ³rio nginx existe
            echo "ğŸ” Checking nginx directory..."
            ls -la
            if [ -d "./nginx" ]; then
              echo "âœ… Nginx directory found"
              ls -la ./nginx/
            else
              echo "âŒ Nginx directory not found! Creating from repository..."
              
              # Criar diretÃ³rio nginx
              mkdir -p nginx
              
              # Baixar arquivos do nginx do repositÃ³rio
              echo "ğŸ“¥ Downloading nginx files from repository..."
              curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                -H "Accept: application/vnd.github.v3.raw" \
                -o nginx/Dockerfile \
                "https://api.github.com/repos/${{ github.repository }}/contents/nginx/Dockerfile?ref=${{ github.ref_name }}"
              
              curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                -H "Accept: application/vnd.github.v3.raw" \
                -o nginx/nginx.conf \
                "https://api.github.com/repos/${{ github.repository }}/contents/nginx/nginx.conf?ref=${{ github.ref_name }}"
              
              # Verificar se arquivos foram baixados
              if [ -f "nginx/Dockerfile" ] && [ -f "nginx/nginx.conf" ]; then
                echo "âœ… Nginx files downloaded successfully"
                ls -la nginx/
              else
                echo "âŒ Failed to download nginx files"
                exit 1
              fi
            fi
            
            sudo docker build -t $IMAGE_NAME .
            sudo docker build -t nginx-proxy ./nginx

            # ğŸ”„ Deploy inteligente - ProduÃ§Ã£o nunca para desnecessariamente
            echo "ğŸ”„ Performing smart deployment for $ENV"
            
            # Deploy de ambientes permanentes (staging e produÃ§Ã£o)
            if [ "$ENV" = "prod" ]; then
              echo "ğŸ­ PRODUCTION DEPLOY - Updating existing container"
              # Para produÃ§Ã£o, apenas atualiza o container existente
              sudo docker stop $CONTAINER_NAME 2>/dev/null || true
              sudo docker rm $CONTAINER_NAME 2>/dev/null || true
            elif [ "$ENV" = "staging" ]; then
              echo "ğŸ§ª STAGING DEPLOY - Updating existing container"
              # Para staging, apenas atualiza o container existente
            sudo docker stop $CONTAINER_NAME 2>/dev/null || true
            sudo docker rm $CONTAINER_NAME 2>/dev/null || true
            fi
            
            # Nginx sempre Ã© recriado para garantir configuraÃ§Ã£o correta
            echo "ğŸŒ Updating nginx configuration..."
            sudo docker stop nginx-proxy 2>/dev/null || true
            sudo docker rm nginx-proxy 2>/dev/null || true

            # ğŸš€ Executa containers com limites de memÃ³ria
            echo "ğŸ¯ Starting containers with memory limits..."
            
            # Backend container com otimizaÃ§Ãµes para 1GB RAM
            sudo docker run -d \
              --name $CONTAINER_NAME \
              --memory=$MEMORY_LIMIT \
              --memory-swap=$MEMORY_LIMIT \
              --cpus="0.5" \
              --oom-kill-disable=false \
              --memory-reservation=$(echo $MEMORY_LIMIT | sed 's/m//' | awk '{print int($1*0.7)"m"}') \
              --shm-size=64m \
              -e JAVA_OPTS="$JAVA_OPTS" \
              -e SPRING_PROFILES_ACTIVE=production \
              -e SPRING_DATASOURCE_URL="${{ secrets.SPRING_DATASOURCE_URL }}" \
              -e SPRING_DATASOURCE_USERNAME="${{ secrets.SPRING_DATASOURCE_USERNAME }}" \
              -e SPRING_DATASOURCE_PASSWORD="${{ secrets.SPRING_DATASOURCE_PASSWORD }}" \
              -e SPRING_KAFKA_BOOTSTRAP_SERVERS="${{ secrets.SPRING_KAFKA_BOOTSTRAP_SERVERS }}" \
              -e SPRING_JPA_HIBERNATE_DDL_AUTO=validate \
              -e SPRING_JPA_HIBERNATE_SHOW_SQL=false \
              -e LOGGING_LEVEL_ORG_HIBERNATE=ERROR \
              -e LOGGING_LEVEL_ORG_SPRINGFRAMEWORK=WARN \
              --restart unless-stopped \
              --health-cmd="curl -f http://localhost:8080/actuator/health || exit 1" \
              --health-interval=60s \
              --health-timeout=30s \
              --health-retries=5 \
              --health-start-period=120s \
              $IMAGE_NAME

            # Nginx container otimizado para 1GB RAM
            echo "ğŸŒ Starting nginx container..."
            sudo docker run -d \
              --name nginx-proxy \
              --memory=50m \
              --memory-swap=50m \
              --cpus="0.1" \
              --oom-kill-disable=false \
              --memory-reservation=40m \
              -p 80:80 \
              -p 443:443 \
              -v $(pwd)/ssl:/etc/nginx/ssl:ro \
              --restart unless-stopped \
              --health-cmd="wget --no-verbose --tries=1 --spider http://localhost/nginx_status || exit 1" \
              --health-interval=30s \
              --health-timeout=5s \
              --health-retries=3 \
              nginx-proxy

            # ğŸ” VerificaÃ§Ã£o PÃ³s-Deploy
            echo "âœ… Deployment completed! Verifying..."
            sleep 30
            
            # Debug: Verificar logs do container
            echo "ğŸ” Checking container logs for issues..."
            sudo docker logs --tail 20 $CONTAINER_NAME || true

            echo "ğŸ“‹ Container status:"
            sudo docker ps --filter "name=$CONTAINER_NAME" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            sudo docker ps --filter "name=nginx-proxy" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"

            echo "ğŸ“Š Memory usage:"
            sudo docker stats $CONTAINER_NAME --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.MemPerc}}" || true
            sudo docker stats nginx-proxy --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.MemPerc}}" || true
            
            # ğŸ§  Verificar uso de memÃ³ria do sistema
            echo "ğŸ” System memory after deploy:"
            free -h
            echo "ğŸ’¾ Memory usage: $(free -m | awk 'NR==2{printf "%.1f%%", $3*100/$2 }')"
            
            # âš ï¸ Alertas de memÃ³ria inteligentes
            USED_MB=$(free -m | awk 'NR==2{print $3}')
            TOTAL_MB=$(free -m | awk 'NR==2{print $2}')
            USAGE_PERCENT=$((USED_MB * 100 / TOTAL_MB))
            
            # Verificar containers ativos
            ACTIVE_CONTAINERS=$(sudo docker ps --format "{{.Names}}" | grep -E "(portfolio-backend|nginx)" | wc -l)
            echo "ğŸ“Š Active containers: $ACTIVE_CONTAINERS"
            
            if [ $USAGE_PERCENT -gt 90 ]; then
              echo "ğŸš¨ CRITICAL: Memory usage is ${USAGE_PERCENT}%! Consider upgrading VM."
              echo "âš ï¸ Both staging and production are permanent - cannot stop them"
            elif [ $USAGE_PERCENT -gt 80 ]; then
              echo "âš ï¸ WARNING: Memory usage is ${USAGE_PERCENT}%. Monitor closely."
              echo "ğŸ“Š Both staging and production are running permanently"
            else
              echo "âœ… Memory usage is healthy: ${USAGE_PERCENT}%"
            fi

            if sudo docker inspect $CONTAINER_NAME &>/dev/null && sudo docker inspect nginx-proxy &>/dev/null; then
              echo "ğŸ’š SUCCESS: Containers deployed successfully!"
              echo "ğŸŒ Access:"
              echo "   - HTTP:  http://${{ env.VM_HOST }}/actuator/health"
              echo "   - HTTPS: https://${{ env.VM_HOST }}/actuator/health"
              echo "   - API:   https://${{ env.VM_HOST }}/api/"
              
              # ğŸ” VerificaÃ§Ã£o final do certificado em uso
              echo "ğŸ” VerificaÃ§Ã£o final do certificado SSL:"
              if [ -f "ssl/cert.pem" ]; then
                CERT_ISSUER=$(openssl x509 -in ssl/cert.pem -noout -issuer 2>/dev/null | cut -d= -f2- || echo "Erro ao ler issuer")
                if echo "$CERT_ISSUER" | grep -q "Let's Encrypt"; then
                  echo "âœ… CERTIFICADO VÃLIDO (Let's Encrypt) - HTTPS seguro!"
                  echo "ğŸ”’ Navegador mostrarÃ¡ cadeado verde"
                else
                  echo "âš ï¸ CERTIFICADO AUTO-ASSINADO - HTTPS com aviso"
                  echo "ğŸ”“ Navegador mostrarÃ¡ aviso de seguranÃ§a"
                fi
              fi
              
              echo ""
              echo "ğŸ“‹ Como verificar no navegador:"
              echo "   1. Acesse: https://${{ env.VM_HOST }}"
              echo "   2. Cadeado verde = Certificado vÃ¡lido"
              echo "   3. Cadeado com aviso = Certificado auto-assinado"
            
              # ğŸ“ Logs iniciais para debug
              echo "ğŸ“‹ Application logs (last 10 lines):"
              sudo docker logs --tail 10 $CONTAINER_NAME
              echo "ğŸ“‹ Nginx logs (last 5 lines):"
              sudo docker logs --tail 5 nginx-proxy
            else
              echo "âŒ ERROR: One or more containers failed to start"
              sudo docker logs $CONTAINER_NAME 2>/dev/null || echo "No backend logs available"
              sudo docker logs nginx-proxy 2>/dev/null || echo "No nginx logs available"
              exit 1
            fi

            # ğŸ§¹ Cleanup de imagens antigas
            echo "ğŸ§¹ Cleaning up old images..."
            sudo docker image prune -af --filter "until=48h"
